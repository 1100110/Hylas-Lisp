<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>core.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>core.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001   <span class="keyword">typedef</span> string (*hFuncPtr)(Form* code);
<a name="l00002"></a>00002   
<a name="l00003"></a>00003   map&lt;string,hFuncPtr&gt; TopLevel;
<a name="l00004"></a>00004   map&lt;string,hFuncPtr&gt; Core;
<a name="l00005"></a>00005   
<a name="l00006"></a>00006   <span class="keywordtype">string</span> def_local(Form* form)
<a name="l00007"></a>00007   {
<a name="l00008"></a>00008     <span class="keywordtype">string</span> varname = val(nth(form,1));
<a name="l00009"></a>00009     <span class="keywordtype">string</span>* result = lookup(varname);
<a name="l00010"></a>00010     <span class="keywordflow">if</span>(result != NULL)
<a name="l00011"></a>00011     {
<a name="l00012"></a>00012       printf(<span class="stringliteral">&quot;ERROR: Symbol already defined.&quot;</span>);
<a name="l00013"></a>00013       Unwind();
<a name="l00014"></a>00014     }
<a name="l00015"></a>00015     <span class="keywordtype">string</span> out = emitCode(nth(form,2));
<a name="l00016"></a>00016     out += allocate(<span class="stringliteral">&quot;%&quot;</span>+varname,latest_type());
<a name="l00017"></a>00017     out += store(latest_type(),get_current_res(),<span class="stringliteral">&quot;%&quot;</span>+varname);
<a name="l00018"></a>00018     <span class="keywordtype">string</span> str = latest_type();
<a name="l00019"></a>00019     SymbolTable[ScopeDepth][varname].sym = str;
<a name="l00020"></a>00020     <span class="keywordflow">return</span> out;
<a name="l00021"></a>00021   }
<a name="l00022"></a>00022   
<a name="l00023"></a>00023   <span class="keywordtype">string</span> def_global(Form* form)
<a name="l00024"></a>00024   {
<a name="l00025"></a>00025     
<a name="l00026"></a>00026   }
<a name="l00027"></a>00027   
<a name="l00028"></a>00028   <span class="keywordtype">string</span> <span class="keyword">set</span>(Form* form)
<a name="l00029"></a>00029   {
<a name="l00030"></a>00030     <span class="keywordtype">string</span> varname = val(nth(form,1));
<a name="l00031"></a>00031     <span class="keywordtype">string</span>* tmp = lookup(varname);
<a name="l00032"></a>00032     <span class="keywordflow">if</span>(tmp == NULL)
<a name="l00033"></a>00033     {
<a name="l00034"></a>00034       error_unbound(nth(form,1));
<a name="l00035"></a>00035     }
<a name="l00036"></a>00036     <span class="keywordtype">string</span> out = emitCode(nth(form,2));
<a name="l00037"></a>00037     out += store(latest_type(),get_current_res(),<span class="stringliteral">&quot;%&quot;</span>+varname);
<a name="l00038"></a>00038     <span class="keywordflow">return</span> out;
<a name="l00039"></a>00039   }
<a name="l00040"></a>00040   
<a name="l00041"></a>00041   <span class="keywordtype">string</span> ret(Form* form)
<a name="l00042"></a>00042   {
<a name="l00043"></a>00043     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> l = length(form);
<a name="l00044"></a>00044     <span class="keywordflow">if</span>(l != 2)
<a name="l00045"></a>00045     {
<a name="l00046"></a>00046       printf(<span class="stringliteral">&quot;ERROR: (return) takes exactly one argument, but %li were provided.&quot;</span>, l);
<a name="l00047"></a>00047       Unwind();
<a name="l00048"></a>00048     }
<a name="l00049"></a>00049     <span class="keywordtype">string</span> out = emitCode(nth(form,1));
<a name="l00050"></a>00050     out += <span class="stringliteral">&quot;ret &quot;</span> + latest_type() + <span class="stringliteral">&quot; &quot;</span> + get_current_res();
<a name="l00051"></a>00051     <span class="keywordflow">return</span> out;
<a name="l00052"></a>00052   }
<a name="l00053"></a>00053   
<a name="l00054"></a>00054   <span class="keywordtype">string</span> generic_math(Form* form, <span class="keywordtype">string</span> opcode)
<a name="l00055"></a>00055   {
<a name="l00056"></a>00056     <span class="keywordtype">string</span> out = emitCode(nth(form,1));
<a name="l00057"></a>00057     out += emitCode(nth(form,2));
<a name="l00058"></a>00058     <span class="keywordflow">return</span> out + get_unique_res(latest_type()) + <span class="stringliteral">&quot; = &quot;</span> + opcode + <span class="stringliteral">&quot; &quot;</span> + latest_type()
<a name="l00059"></a>00059     + <span class="stringliteral">&quot; &quot;</span> + get_res(tmp_version - 1) + <span class="stringliteral">&quot;, &quot;</span> + get_res(tmp_version);
<a name="l00060"></a>00060   }
<a name="l00061"></a>00061   
<a name="l00062"></a>00062   <span class="keywordtype">string</span> add(Form* form)                {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;add&quot;</span>);}
<a name="l00063"></a>00063   <span class="keywordtype">string</span> fadd(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;fadd&quot;</span>);}
<a name="l00064"></a>00064   <span class="keywordtype">string</span> sub(Form* form)                {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;sub&quot;</span>);}
<a name="l00065"></a>00065   <span class="keywordtype">string</span> fsub(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;fsub&quot;</span>);}
<a name="l00066"></a>00066   <span class="keywordtype">string</span> mul(Form* form)                {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;mul&quot;</span>);}
<a name="l00067"></a>00067   <span class="keywordtype">string</span> fmul(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;fmul&quot;</span>);}
<a name="l00068"></a>00068   <span class="keywordtype">string</span> udiv(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;udiv&quot;</span>);}
<a name="l00069"></a>00069   <span class="keywordtype">string</span> sdiv(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;sdiv&quot;</span>);}
<a name="l00070"></a>00070   <span class="keywordtype">string</span> fdiv(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;fdiv&quot;</span>);}
<a name="l00071"></a>00071   <span class="keywordtype">string</span> urem(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;urem&quot;</span>);}
<a name="l00072"></a>00072   <span class="keywordtype">string</span> srem(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;srem&quot;</span>);}
<a name="l00073"></a>00073   <span class="keywordtype">string</span> frem(Form* form)               {<span class="keywordflow">return</span> generic_math(form,<span class="stringliteral">&quot;frem&quot;</span>);}
<a name="l00074"></a>00074   
<a name="l00075"></a>00075   <span class="keywordtype">string</span> icmp(Form* form)
<a name="l00076"></a>00076   {
<a name="l00077"></a>00077     <span class="keywordtype">string</span> out;
<a name="l00078"></a>00078     <span class="keywordtype">string</span> cmp_code = val(nth(form,1));
<a name="l00079"></a>00079     out += emitCode(nth(form,2));
<a name="l00080"></a>00080     out += emitCode(nth(form,3));
<a name="l00081"></a>00081     <span class="keywordflow">return</span> out + get_unique_res(latest_type()) + <span class="stringliteral">&quot; = icmp &quot;</span> + cmp_code + <span class="stringliteral">&quot; &quot;</span>
<a name="l00082"></a>00082     + latest_type() + <span class="stringliteral">&quot; &quot;</span> + get_res(res_version-1) + <span class="stringliteral">&quot;, &quot;</span> + get_res(res_version);
<a name="l00083"></a>00083   }
<a name="l00084"></a>00084   
<a name="l00085"></a>00085   <span class="keywordtype">string</span> fcmp(Form* form)
<a name="l00086"></a>00086   {
<a name="l00087"></a>00087     <span class="keywordtype">string</span> out;
<a name="l00088"></a>00088     <span class="keywordtype">string</span> cmp_code = val(nth(form,1));
<a name="l00089"></a>00089     out += emitCode(nth(form,2));
<a name="l00090"></a>00090     out += emitCode(nth(form,3));
<a name="l00091"></a>00091     <span class="keywordflow">return</span> out + get_unique_res(latest_type()) + <span class="stringliteral">&quot; = fcmp &quot;</span> + cmp_code + <span class="stringliteral">&quot; &quot;</span>
<a name="l00092"></a>00092     + latest_type() + <span class="stringliteral">&quot; &quot;</span> + get_res(res_version-1) + <span class="stringliteral">&quot;, &quot;</span> + get_res(res_version);
<a name="l00093"></a>00093   }
<a name="l00094"></a>00094   
<a name="l00095"></a>00095   <span class="keywordtype">string</span> access(Form* form)
<a name="l00096"></a>00096   {
<a name="l00097"></a>00097     <span class="keywordtype">string</span> out = emitCode(nth(form,1));
<a name="l00098"></a>00098     <span class="keywordtype">string</span> type = latest_type();
<a name="l00099"></a>00099     <span class="keywordtype">string</span> type_cdr = string(type,1);
<a name="l00100"></a>00100     <span class="keywordtype">string</span> member = val(nth(form,2));
<a name="l00101"></a>00101     <span class="keywordtype">string</span> member_type;
<a name="l00102"></a>00102     <span class="keywordtype">string</span> member_loc;
<a name="l00103"></a>00103     <span class="comment">//Find in BasicTypes</span>
<a name="l00104"></a>00104     map&lt;string,Type&gt;::iterator seeker = BasicTypes.find(type_cdr);
<a name="l00105"></a>00105     <span class="keywordflow">if</span>(seeker != BasicTypes.end())
<a name="l00106"></a>00106     {
<a name="l00107"></a>00107       <span class="comment">//Found matching type name, check if it&#39;s a structur</span>
<a name="l00108"></a>00108       <span class="keywordflow">if</span>(seeker-&gt;second.id == typeStructure)
<a name="l00109"></a>00109       {
<a name="l00110"></a>00110         <span class="comment">//Passed, check if it has that member</span>
<a name="l00111"></a>00111         map&lt;string,pair&lt;long,string&gt; &gt;::iterator checker = seeker-&gt;second.members.find(member);
<a name="l00112"></a>00112         <span class="keywordflow">if</span>(checker != seeker-&gt;second.members.end())
<a name="l00113"></a>00113         {
<a name="l00114"></a>00114           <span class="comment">//Passed, record the member position</span>
<a name="l00115"></a>00115           member_loc = to_string&lt;long&gt;(checker-&gt;second.first);
<a name="l00116"></a>00116           member_type = checker-&gt;second.second;  
<a name="l00117"></a>00117         }
<a name="l00118"></a>00118         <span class="keywordflow">else</span>
<a name="l00119"></a>00119         {
<a name="l00120"></a>00120           printf(<span class="stringliteral">&quot;ERROR: Type &#39;%s&#39; does not have the member &#39;%s&#39;&quot;</span>,type_cdr.c_str(),member.c_str());
<a name="l00121"></a>00121           Unwind();
<a name="l00122"></a>00122         }
<a name="l00123"></a>00123       }
<a name="l00124"></a>00124       <span class="keywordflow">else</span>
<a name="l00125"></a>00125       {
<a name="l00126"></a>00126         printf(<span class="stringliteral">&quot;ERROR: Type &#39;%s&#39; not a structure.&quot;</span>,type_cdr.c_str());
<a name="l00127"></a>00127         Unwind();
<a name="l00128"></a>00128       }
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130     <span class="comment">//Find in Generics</span>
<a name="l00131"></a>00131     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; Generics.size(); i++)
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133       map&lt;string,map&lt;string,pair&lt;long,string&gt; &gt; &gt;::iterator finder = Generics[i].second.specializations.find(type);
<a name="l00134"></a>00134       <span class="keywordflow">if</span>(finder != Generics[i].second.specializations.end())
<a name="l00135"></a>00135       {
<a name="l00136"></a>00136         map&lt;string,pair&lt;long,string&gt; &gt;::iterator checker = finder-&gt;second.find(member);
<a name="l00137"></a>00137         <span class="keywordflow">if</span>(checker != Generics[i].second.members.end())
<a name="l00138"></a>00138         {
<a name="l00139"></a>00139           <span class="comment">//Passed, record the member position</span>
<a name="l00140"></a>00140           member_loc = to_string&lt;long&gt;(checker-&gt;second.first);
<a name="l00141"></a>00141           member_type = checker-&gt;second.second;
<a name="l00142"></a>00142         }
<a name="l00143"></a>00143       }
<a name="l00144"></a>00144       <span class="keywordflow">if</span>(i == Generics.size()-1)
<a name="l00145"></a>00145       {
<a name="l00146"></a>00146         printf(<span class="stringliteral">&quot;ERROR: Improper type passed to (access).&quot;</span>);
<a name="l00147"></a>00147         Unwind();
<a name="l00148"></a>00148       }
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150     <span class="comment">//Emit code</span>
<a name="l00151"></a>00151     out += get_unique_tmp() + <span class="stringliteral">&quot; = getelementptr inbounds &quot;</span> + type + <span class="stringliteral">&quot; &quot;</span> + get_current_res() + <span class="stringliteral">&quot;, i32 0, i32&quot;</span> + member_loc + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00152"></a>00152     out += load(get_unique_res(member_type),member_type,get_current_tmp());
<a name="l00153"></a>00153     <span class="keywordflow">return</span> out;
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155   
<a name="l00156"></a>00156   <span class="keywordtype">string</span> simple_if(Form* form)
<a name="l00157"></a>00157   {
<a name="l00158"></a>00158     <span class="keywordtype">string</span> out = emitCode(nth(form,1));
<a name="l00159"></a>00159     <span class="keywordflow">if</span>(latest_type() != <span class="stringliteral">&quot;i1&quot;</span>)
<a name="l00160"></a>00160     {
<a name="l00161"></a>00161       out += <span class="stringliteral">&quot;\nbr i1 true,&quot;</span>;
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163     <span class="keywordflow">else</span>
<a name="l00164"></a>00164       out += <span class="stringliteral">&quot;\nbr i1 &quot;</span> + get_current_res() + <span class="stringliteral">&quot;,&quot;</span>;
<a name="l00165"></a>00165     out += <span class="stringliteral">&quot; label &quot;</span> + get_unique_label() + <span class="stringliteral">&quot;, label &quot;</span> + get_unique_label();
<a name="l00166"></a>00166     out += string(get_label(label_version - 1),1) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00167"></a>00167     out += emitCode(nth(form,2));
<a name="l00168"></a>00168     out += <span class="stringliteral">&quot;br &quot;</span> + get_label(label_version+1) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00169"></a>00169     out += string(get_label(label_version - 2),1) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00170"></a>00170     out += emitCode(nth(form,3));
<a name="l00171"></a>00171     out += get_unique_label();
<a name="l00172"></a>00172     out += get_unique_res(latest_type()) + <span class="stringliteral">&quot; = phi &quot;</span> + latest_type() + <span class="stringliteral">&quot; [true, &quot;</span> + get_label(label_version - 2) + <span class="stringliteral">&quot;], [false, &quot;</span> + get_label(label_version - 3) + <span class="stringliteral">&quot;]&quot;</span>;
<a name="l00173"></a>00173     <span class="keywordflow">return</span> out;
<a name="l00174"></a>00174   }
<a name="l00175"></a>00175   
<a name="l00176"></a>00176   <span class="keywordtype">string</span> flow(Form* form)
<a name="l00177"></a>00177   {
<a name="l00178"></a>00178     <span class="keywordtype">string</span> out = emitCode(nth(form,1));
<a name="l00179"></a>00179     <span class="keywordflow">if</span>(latest_type() != <span class="stringliteral">&quot;i1&quot;</span>)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181       out += <span class="stringliteral">&quot;br i1 true,&quot;</span>;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183     <span class="keywordflow">else</span>
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185       out += <span class="stringliteral">&quot;br i1 &quot;</span> + get_current_res() + <span class="stringliteral">&quot;,&quot;</span>;
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187     out += <span class="stringliteral">&quot; label &quot;</span> + get_unique_label() + <span class="stringliteral">&quot;, label &quot;</span> + get_unique_label() + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00188"></a>00188     out += string(get_label(label_version - 1),1) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00189"></a>00189     out += emitCode(nth(form,2));
<a name="l00190"></a>00190     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> save = res_version;
<a name="l00191"></a>00191     out += <span class="stringliteral">&quot;br &quot;</span> + get_label(label_version+1) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00192"></a>00192     out += string(get_label(label_version - 2),1) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00193"></a>00193     out += emitCode(nth(form,3));
<a name="l00194"></a>00194     out += get_unique_label();
<a name="l00195"></a>00195     out += get_unique_res(latest_type()) + <span class="stringliteral">&quot; = phi &quot;</span> + latest_type() + <span class="stringliteral">&quot; [&quot;</span> + get_res(save) + <span class="stringliteral">&quot;, &quot;</span> + get_label(label_version - 1) + <span class="stringliteral">&quot;], [&quot;</span> + get_res(res_version - 2) + <span class="stringliteral">&quot;, &quot;</span> + get_label(label_version - 3) + <span class="stringliteral">&quot;]&quot;</span>;
<a name="l00196"></a>00196     <span class="keywordflow">return</span> out;
<a name="l00197"></a>00197   }
<a name="l00198"></a>00198   
<a name="l00199"></a>00199   <span class="keywordtype">string</span> begin(Form* form)
<a name="l00200"></a>00200   {
<a name="l00201"></a>00201     <span class="keywordtype">string</span> out;
<a name="l00202"></a>00202     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; length(form); i++)
<a name="l00203"></a>00203       out += emitCode(nth(form,i));
<a name="l00204"></a>00204     <span class="keywordflow">return</span> out;
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206   
<a name="l00207"></a>00207   <span class="keywordtype">string</span> main_fn(Form* form)
<a name="l00208"></a>00208   {
<a name="l00209"></a>00209     <span class="keywordtype">string</span> out = <span class="stringliteral">&quot;define i32 @main(i32 %argc, i8** %argv) nounwind&quot;</span>;
<a name="l00210"></a>00210     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; length(form); i++)
<a name="l00211"></a>00211       out += emitCode(nth(form,i));
<a name="l00212"></a>00212     <span class="keywordflow">return</span> out + <span class="stringliteral">&quot;\n}&quot;</span>;
<a name="l00213"></a>00213   }
<a name="l00214"></a>00214   
<a name="l00215"></a>00215   <span class="keywordtype">string</span> declare(Form* form)
<a name="l00216"></a>00216   {
<a name="l00217"></a>00217     <span class="keywordtype">string</span> out = <span class="stringliteral">&quot;declare &quot;</span> + val(nth(form,2)) + <span class="stringliteral">&quot; @&quot;</span> + val(nth(form,1)) + <span class="stringliteral">&quot;(&quot;</span>;
<a name="l00218"></a>00218     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 3; i &lt;= length(form)-1; i++)
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220       out += val(nth(form,i)) + <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222     <span class="keywordflow">return</span> cutlast(out) + <span class="stringliteral">&quot;)\n&quot;</span>;                
<a name="l00223"></a>00223   }
<a name="l00224"></a>00224   
<a name="l00225"></a>00225   <span class="keywordtype">string</span> embed_llvm(Form* form)
<a name="l00226"></a>00226   {
<a name="l00227"></a>00227     <span class="keywordtype">string</span> out = print(cdr(form));
<a name="l00228"></a>00228     <span class="keywordflow">return</span> string(out,1,out.length()-2);
<a name="l00229"></a>00229   }
<a name="l00230"></a>00230   
<a name="l00231"></a>00231   <span class="keywordtype">string</span> define_function(Form* form)
<a name="l00232"></a>00232   {
<a name="l00233"></a>00233     defineFunction(form,Function,noinline);
<a name="l00234"></a>00234     <span class="keywordtype">string</span> out = fn_code;
<a name="l00235"></a>00235     fn_code = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00236"></a>00236     <span class="keywordflow">return</span> out;
<a name="l00237"></a>00237   }
<a name="l00238"></a>00238   
<a name="l00239"></a>00239   <span class="keywordtype">string</span> define_recursive(Form* form)
<a name="l00240"></a>00240   {
<a name="l00241"></a>00241     defineFunction(form,Recursive,noinline);
<a name="l00242"></a>00242     <span class="keywordtype">string</span> out = fn_code;
<a name="l00243"></a>00243     fn_code = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00244"></a>00244     <span class="keywordflow">return</span> out;
<a name="l00245"></a>00245   }
<a name="l00246"></a>00246   
<a name="l00247"></a>00247   <span class="keywordtype">string</span> define_fast(Form* form)
<a name="l00248"></a>00248   {
<a name="l00249"></a>00249     defineFunction(form,Fast,noinline);
<a name="l00250"></a>00250     <span class="keywordtype">string</span> out = fn_code;
<a name="l00251"></a>00251     fn_code = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00252"></a>00252     <span class="keywordflow">return</span> out;
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254   
<a name="l00255"></a>00255   <span class="keywordtype">string</span> define_inline(Form* form)
<a name="l00256"></a>00256   {
<a name="l00257"></a>00257     defineFunction(form,Function,doinline);
<a name="l00258"></a>00258     <span class="keywordtype">string</span> out = fn_code;
<a name="l00259"></a>00259     fn_code = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00260"></a>00260     <span class="keywordflow">return</span> out;
<a name="l00261"></a>00261   }
<a name="l00262"></a>00262   
<a name="l00263"></a>00263   <span class="keywordtype">string</span> define_inline_recursive(Form* form)
<a name="l00264"></a>00264   {
<a name="l00265"></a>00265     defineFunction(form,Recursive,doinline);
<a name="l00266"></a>00266     <span class="keywordtype">string</span> out = fn_code;
<a name="l00267"></a>00267     fn_code = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00268"></a>00268     <span class="keywordflow">return</span> out;
<a name="l00269"></a>00269   }
<a name="l00270"></a>00270   
<a name="l00271"></a>00271   <span class="keywordtype">string</span> define_inline_fast(Form* form)
<a name="l00272"></a>00272   {
<a name="l00273"></a>00273     defineFunction(form,Fast,doinline);
<a name="l00274"></a>00274     <span class="keywordtype">string</span> out = fn_code;
<a name="l00275"></a>00275     fn_code = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00276"></a>00276     <span class="keywordflow">return</span> out;
<a name="l00277"></a>00277   }
<a name="l00278"></a>00278   
<a name="l00279"></a>00279   <span class="keywordtype">string</span> direct_call(Form* form)
<a name="l00280"></a>00280   {
<a name="l00281"></a>00281     <span class="keywordtype">string</span> out;
<a name="l00282"></a>00282     <span class="keywordtype">string</span> name = val(nth(form,1));
<a name="l00283"></a>00283     <span class="keywordtype">string</span> ret_type = val(nth(form,2));
<a name="l00284"></a>00284     <span class="keywordtype">string</span> c_conv = val(nth(form,3));
<a name="l00285"></a>00285     map&lt;long,string&gt; inputs;
<a name="l00286"></a>00286     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; length(form); i++)
<a name="l00287"></a>00287     {
<a name="l00288"></a>00288       out += emitCode(nth(form,i));
<a name="l00289"></a>00289       inputs[res_version] = latest_type();
<a name="l00290"></a>00290     }
<a name="l00291"></a>00291     out += (string)<span class="stringliteral">&quot;call &quot;</span> + ret_type + <span class="stringliteral">&quot; &quot;</span> + c_conv + <span class="stringliteral">&quot; @&quot;</span> + name + <span class="stringliteral">&quot;(&quot;</span>;
<a name="l00292"></a>00292     <span class="keywordflow">for</span>(map&lt;long,string&gt;::iterator seeker = inputs.begin(); seeker != inputs.end(); seeker++)
<a name="l00293"></a>00293     {
<a name="l00294"></a>00294       out += seeker-&gt;second + <span class="stringliteral">&quot; &quot;</span> + get_res(seeker-&gt;first) + <span class="stringliteral">&quot;,&quot;</span>;
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296     <span class="keywordflow">return</span> cutlast(out) + <span class="stringliteral">&quot;)&quot;</span>;
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298   
<a name="l00299"></a>00299   <span class="keywordtype">string</span> construct(Form* form)
<a name="l00300"></a>00300   {
<a name="l00301"></a>00301     <span class="comment">//(construct [structure or generic] a_1 a_2 ... a_n)</span>
<a name="l00302"></a>00302     <span class="keywordtype">string</span> out;
<a name="l00303"></a>00303     <span class="keywordtype">string</span> type = printTypeSignature(nth(form,1));
<a name="l00304"></a>00304     <span class="keywordtype">string</span> type_cdr = string(type,1);
<a name="l00305"></a>00305     <span class="keywordtype">long</span> nargs = length(form)-2;
<a name="l00306"></a>00306     map&lt;long,string&gt; inputs;
<a name="l00307"></a>00307     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l00308"></a>00308     <span class="keywordflow">for</span>(i = 2; i &lt; length(form); i++)
<a name="l00309"></a>00309     {
<a name="l00310"></a>00310       out += emitCode(nth(form,i));
<a name="l00311"></a>00311       inputs[res_version] = latest_type();
<a name="l00312"></a>00312     }
<a name="l00313"></a>00313     out += allocate(get_unique_tmp(),type);
<a name="l00314"></a>00314     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> allocation_point = tmp_version;
<a name="l00315"></a>00315     <span class="comment">//Find in BasicTypes</span>
<a name="l00316"></a>00316     map&lt;string,Type&gt;::iterator seeker = BasicTypes.find(type_cdr);
<a name="l00317"></a>00317     <span class="keywordflow">if</span>(seeker != BasicTypes.end())
<a name="l00318"></a>00318     {
<a name="l00319"></a>00319       <span class="comment">//Found matching type name, check if it&#39;s a structure</span>
<a name="l00320"></a>00320       <span class="keywordflow">if</span>(seeker-&gt;second.id == typeStructure)
<a name="l00321"></a>00321       {
<a name="l00322"></a>00322         <span class="comment">//Passed</span>
<a name="l00323"></a>00323         <span class="keywordflow">if</span>(nargs == seeker-&gt;second.members.size())
<a name="l00324"></a>00324         {
<a name="l00325"></a>00325           <span class="comment">//Iterate over members and compare it to inputs</span>
<a name="l00326"></a>00326           map&lt;long,string&gt;::iterator aide = inputs.begin();
<a name="l00327"></a>00327           <span class="keywordflow">for</span>(map&lt;<span class="keywordtype">string</span>,pair&lt;long,string&gt; &gt;::iterator finder = seeker-&gt;second.members.begin();
<a name="l00328"></a>00328               finder != seeker-&gt;second.members.end(); finder++)
<a name="l00329"></a>00329           {
<a name="l00330"></a>00330             <span class="comment">//Check types</span>
<a name="l00331"></a>00331             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pos = 0;
<a name="l00332"></a>00332             <span class="keywordflow">if</span>(finder-&gt;second.second == aide-&gt;second)
<a name="l00333"></a>00333             {
<a name="l00334"></a>00334               <span class="comment">//Passed, write to out</span>
<a name="l00335"></a>00335               out += get_unique_tmp() + <span class="stringliteral">&quot; = getelementptr inbounds &quot;</span> + type + <span class="stringliteral">&quot;* &quot;</span> + get_tmp(allocation_point)
<a name="l00336"></a>00336                   + <span class="stringliteral">&quot;, i32 0, i32 &quot;</span> + to_string&lt;unsigned long&gt;(pos) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00337"></a>00337               out += store(aide-&gt;second,get_res(aide-&gt;first),get_current_tmp());
<a name="l00338"></a>00338               pos++;
<a name="l00339"></a>00339             }
<a name="l00340"></a>00340             <span class="keywordflow">else</span>
<a name="l00341"></a>00341               error(NormalError,<span class="stringliteral">&quot;Wrong type: &quot;</span>,finder-&gt;second.second,<span class="stringliteral">&quot; does not match &quot;</span>,
<a name="l00342"></a>00342                       aide-&gt;second,<span class="stringliteral">&quot;.&quot;</span>);
<a name="l00343"></a>00343             aide++;
<a name="l00344"></a>00344           }
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346         <span class="keywordflow">else</span>
<a name="l00347"></a>00347         {
<a name="l00348"></a>00348           printf(<span class="stringliteral">&quot;ERROR: Wrong number of args.&quot;</span>);
<a name="l00349"></a>00349           Unwind();
<a name="l00350"></a>00350         }
<a name="l00351"></a>00351       }
<a name="l00352"></a>00352       <span class="keywordflow">else</span>
<a name="l00353"></a>00353       {
<a name="l00354"></a>00354         printf(<span class="stringliteral">&quot;ERROR: Type &#39;%s&#39; not a structure.&quot;</span>,type_cdr.c_str());
<a name="l00355"></a>00355         Unwind();
<a name="l00356"></a>00356       }
<a name="l00357"></a>00357     }
<a name="l00358"></a>00358     <span class="comment">//Find in Generics</span>
<a name="l00359"></a>00359     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; Generics.size(); i++)
<a name="l00360"></a>00360     {
<a name="l00361"></a>00361       <span class="keywordflow">if</span>(Generics[i].second.id == typeStructure)
<a name="l00362"></a>00362       {
<a name="l00363"></a>00363         <span class="comment">//Found a structure</span>
<a name="l00364"></a>00364         map&lt;string,map&lt;string,pair&lt;long,string&gt; &gt; &gt;::iterator finder = Generics[i].second.specializations.find(type);
<a name="l00365"></a>00365         <span class="keywordflow">if</span>(finder != Generics[i].second.specializations.end())
<a name="l00366"></a>00366         {
<a name="l00367"></a>00367           <span class="comment">//Found the type in the Generic&#39;s specializations</span>
<a name="l00368"></a>00368           <span class="keywordflow">if</span>(nargs == finder-&gt;second.size())
<a name="l00369"></a>00369           {
<a name="l00370"></a>00370             <span class="comment">//Iterate over members and compare it to inputs</span>
<a name="l00371"></a>00371             <span class="comment">//Check types</span>
<a name="l00372"></a>00372             map&lt;long,string&gt;::iterator aide = inputs.begin();
<a name="l00373"></a>00373             <span class="keywordflow">for</span>(map&lt;<span class="keywordtype">string</span>,pair&lt;long,string&gt; &gt;::iterator looker = finder-&gt;second.begin();
<a name="l00374"></a>00374               looker != finder-&gt;second.end(); looker++)
<a name="l00375"></a>00375             {
<a name="l00376"></a>00376               <span class="comment">//Check types</span>
<a name="l00377"></a>00377               <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pos = 0;
<a name="l00378"></a>00378               <span class="keywordflow">if</span>(looker-&gt;second.second == aide-&gt;second)
<a name="l00379"></a>00379               {
<a name="l00380"></a>00380                 <span class="comment">//Passed, write to out</span>
<a name="l00381"></a>00381                 out += get_unique_tmp() + <span class="stringliteral">&quot; = getelementptr inbounds &quot;</span> + type + <span class="stringliteral">&quot;* &quot;</span> + get_tmp(allocation_point)
<a name="l00382"></a>00382                     + <span class="stringliteral">&quot;, i32 0, i32 &quot;</span> + to_string&lt;unsigned long&gt;(pos) + <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00383"></a>00383                 out += store(aide-&gt;second,get_res(aide-&gt;first),get_current_tmp());
<a name="l00384"></a>00384                 pos++;
<a name="l00385"></a>00385               }
<a name="l00386"></a>00386               <span class="keywordflow">else</span>
<a name="l00387"></a>00387               {
<a name="l00388"></a>00388                 error(NormalError,<span class="stringliteral">&quot;Wrong type: &quot;</span>,looker-&gt;second.second,<span class="stringliteral">&quot; does not match &quot;</span>,
<a name="l00389"></a>00389                       aide-&gt;second,<span class="stringliteral">&quot;.&quot;</span>);
<a name="l00390"></a>00390               }
<a name="l00391"></a>00391               aide++;
<a name="l00392"></a>00392             }
<a name="l00393"></a>00393             <span class="comment">//Passed, write to out</span>
<a name="l00394"></a>00394           }
<a name="l00395"></a>00395           <span class="keywordflow">else</span>
<a name="l00396"></a>00396           {
<a name="l00397"></a>00397             printf(<span class="stringliteral">&quot;ERROR: Wrong number of args.&quot;</span>);
<a name="l00398"></a>00398             Unwind();
<a name="l00399"></a>00399           }
<a name="l00400"></a>00400         }
<a name="l00401"></a>00401         <span class="keywordflow">if</span>(i == Generics.size()-1)
<a name="l00402"></a>00402         {
<a name="l00403"></a>00403           printf(<span class="stringliteral">&quot;ERROR: Improper type passed to (construct).&quot;</span>);
<a name="l00404"></a>00404           Unwind();
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406       }
<a name="l00407"></a>00407     }
<a name="l00408"></a>00408     <span class="comment">//Emit code</span>
<a name="l00409"></a>00409     out += load(get_unique_res(type),type,get_tmp(allocation_point));
<a name="l00410"></a>00410     <span class="keywordflow">return</span> out;
<a name="l00411"></a>00411   }
<a name="l00412"></a>00412   
<a name="l00413"></a>00413   <span class="keywordtype">string</span> make_array(Form* form, <span class="keywordtype">bool</span> global)
<a name="l00414"></a>00414   {
<a name="l00415"></a>00415     <span class="keywordtype">string</span> out;
<a name="l00416"></a>00416     <span class="keywordtype">string</span> type;
<a name="l00417"></a>00417     vector&lt;long&gt; inputs;
<a name="l00418"></a>00418     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 1;
<a name="l00419"></a>00419     <span class="keywordflow">for</span>(; i &lt; length(form); i++)
<a name="l00420"></a>00420     {
<a name="l00421"></a>00421       out += emitCode(nth(form,i));
<a name="l00422"></a>00422       <span class="keywordflow">if</span>(!type.empty())
<a name="l00423"></a>00423         <span class="keywordflow">if</span>(latest_type() != type)
<a name="l00424"></a>00424           error(<span class="stringliteral">&quot;When building an array, the types of all the elements must match.&quot;</span>,
<a name="l00425"></a>00425                 <span class="stringliteral">&quot;The first type mismatch occured at &#39;&quot;</span>,nth(form,i),<span class="stringliteral">&quot;&#39;.&quot;</span>,at(form));
<a name="l00426"></a>00426       inputs.push_back(res_version);
<a name="l00427"></a>00427       type = latest_type();
<a name="l00428"></a>00428     }
<a name="l00429"></a>00429     <span class="keywordtype">string</span> array_type;
<a name="l00430"></a>00430     array_type = <span class="stringliteral">&quot;[&quot;</span> + to_string&lt;long&gt;(length(form)-1) + <span class="stringliteral">&quot; x &quot;</span> + type + <span class="stringliteral">&quot;]&quot;</span>;
<a name="l00431"></a>00431     <span class="keywordtype">string</span> address = (string)(global ? <span class="stringliteral">&quot;@&quot;</span> : <span class="stringliteral">&quot;%&quot;</span>) + <span class="stringliteral">&quot;array&quot;</span> + to_string&lt;unsigned long&gt;(++array_version);
<a name="l00432"></a>00432     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> address_pos;
<a name="l00433"></a>00433     <span class="keywordflow">if</span>(global)
<a name="l00434"></a>00434       push(address + <span class="stringliteral">&quot; = global &quot;</span> + array_type + <span class="stringliteral">&quot; zeroinitializer&quot;</span>);
<a name="l00435"></a>00435     <span class="keywordflow">else</span>
<a name="l00436"></a>00436     {
<a name="l00437"></a>00437       out += allocate(address,array_type);
<a name="l00438"></a>00438       address_pos = tmp_version;
<a name="l00439"></a>00439     }
<a name="l00440"></a>00440     <span class="keywordflow">for</span>(i = 0; i &lt; inputs.size(); i++)
<a name="l00441"></a>00441     {
<a name="l00442"></a>00442       out += get_unique_tmp() + <span class="stringliteral">&quot; = getelementptr inbounds &quot;</span> + array_type + <span class="stringliteral">&quot;* &quot;</span> + address + <span class="stringliteral">&quot;, i64 0, i64 &quot;</span> + to_string&lt;unsigned long&gt;(i);
<a name="l00443"></a>00443       out += store(type,get_res(inputs[i]),get_current_tmp());
<a name="l00444"></a>00444     }
<a name="l00445"></a>00445     out += get_unique_res(type + <span class="stringliteral">&quot;*&quot;</span>) + <span class="stringliteral">&quot; = getelementptr inbounds &quot;</span> + array_type + <span class="stringliteral">&quot;* &quot;</span> + address
<a name="l00446"></a>00446         + <span class="stringliteral">&quot;, i64 0, i64 0&quot;</span>;
<a name="l00447"></a>00447     <span class="keywordflow">return</span> out;
<a name="l00448"></a>00448   }
<a name="l00449"></a>00449   
<a name="l00450"></a>00450   <span class="keywordtype">string</span> global_array(Form* in)
<a name="l00451"></a>00451   {
<a name="l00452"></a>00452     <span class="keywordflow">return</span> make_array(in,<span class="keyword">true</span>);
<a name="l00453"></a>00453   }
<a name="l00454"></a>00454   
<a name="l00455"></a>00455   <span class="keywordtype">string</span> local_array(Form* in)
<a name="l00456"></a>00456   {
<a name="l00457"></a>00457     <span class="keywordflow">return</span> make_array(in,<span class="keyword">false</span>);
<a name="l00458"></a>00458   }
<a name="l00459"></a>00459   
<a name="l00460"></a>00460   <span class="keywordtype">string</span> nth_array(Form* in)
<a name="l00461"></a>00461   {
<a name="l00462"></a>00462     <span class="keywordtype">string</span> out;
<a name="l00463"></a>00463     <span class="comment">//Code for address</span>
<a name="l00464"></a>00464     out += emitCode(nth(in,1));
<a name="l00465"></a>00465     <span class="keywordtype">long</span> address_location = res_version;
<a name="l00466"></a>00466     <span class="comment">//Code for array</span>
<a name="l00467"></a>00467     out += emitCode(nth(in,2));
<a name="l00468"></a>00468     out += get_unique_tmp() + <span class="stringliteral">&quot; = getelementptr inbounds &quot;</span> + latest_type() + <span class="stringliteral">&quot;* &quot;</span> + get_current_res()
<a name="l00469"></a>00469         + <span class="stringliteral">&quot;, i64 &quot;</span> + get_res(address_location);
<a name="l00470"></a>00470     out += load(get_unique_res(cutlast(latest_type())),latest_type(),get_current_tmp());
<a name="l00471"></a>00471     <span class="keywordflow">return</span> out;
<a name="l00472"></a>00472   }
<a name="l00473"></a>00473   
<a name="l00474"></a>00474   <span class="keywordtype">string</span> mem_allocate(Form* in)
<a name="l00475"></a>00475   {
<a name="l00476"></a>00476     <span class="comment">//%x = allocate [type]</span>
<a name="l00477"></a>00477     <span class="keywordtype">string</span> type = printTypeSignature(nth(in,1));
<a name="l00478"></a>00478     <span class="keywordtype">string</span> out = allocate(get_unique_tmp(),type);
<a name="l00479"></a>00479     out += allocate(get_unique_res(type+<span class="stringliteral">&quot;*&quot;</span>),type);
<a name="l00480"></a>00480     <span class="keywordflow">return</span> out;
<a name="l00481"></a>00481   }
<a name="l00482"></a>00482   
<a name="l00483"></a>00483   <span class="keywordtype">string</span> mem_store(Form* in)
<a name="l00484"></a>00484   {
<a name="l00485"></a>00485     <span class="comment">//%x = store [type] [value], [type]* [address]</span>
<a name="l00486"></a>00486     <span class="keywordtype">string</span> out;
<a name="l00487"></a>00487     <span class="comment">//emit value</span>
<a name="l00488"></a>00488     out += emitCode(nth(in,1));
<a name="l00489"></a>00489     <span class="keywordtype">string</span> type = latest_type();
<a name="l00490"></a>00490     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> version = res_version;
<a name="l00491"></a>00491     <span class="comment">//emit address</span>
<a name="l00492"></a>00492     out += emitCode(nth(in,2));
<a name="l00493"></a>00493     <span class="keywordflow">if</span>(cutlast(latest_type()) != type)
<a name="l00494"></a>00494       error(<span class="stringliteral">&quot;The type of the value (&quot;</span>,type,<span class="stringliteral">&quot;) does not equal the type of the address (&quot;</span>,latest_type(),<span class="stringliteral">&quot;).&quot;</span>);
<a name="l00495"></a>00495     out += store(type,get_res(version),get_current_res());
<a name="l00496"></a>00496     <span class="keywordflow">return</span> out;
<a name="l00497"></a>00497   }
<a name="l00498"></a>00498   
<a name="l00499"></a>00499   <span class="keywordtype">string</span> mem_load(Form* in)
<a name="l00500"></a>00500   {
<a name="l00501"></a>00501     <span class="comment">//%x = load [type] [address]; Don&#39;t add an asterisk to the type!</span>
<a name="l00502"></a>00502     <span class="comment">//The type of the address must already be a pointer!</span>
<a name="l00503"></a>00503     <span class="comment">//emit address</span>
<a name="l00504"></a>00504     <span class="keywordtype">string</span> out = emitCode(nth(in,1));
<a name="l00505"></a>00505     <span class="keywordtype">string</span> type = latest_type();
<a name="l00506"></a>00506     <span class="keywordflow">if</span>(type[type.length()-1] != <span class="charliteral">&#39;*&#39;</span>)
<a name="l00507"></a>00507       error(<span class="stringliteral">&quot;Address is not a pointer.&quot;</span>);
<a name="l00508"></a>00508     out += load(get_unique_res(cutlast(type)),type,get_current_res());
<a name="l00509"></a>00509     <span class="keywordflow">return</span> out;
<a name="l00510"></a>00510   }
<a name="l00511"></a>00511   
<a name="l00512"></a>00512   <span class="keywordtype">string</span> pointer(Form* in)
<a name="l00513"></a>00513   {
<a name="l00514"></a>00514     <span class="keywordtype">string</span> out = emitCode(nth(in,1));
<a name="l00515"></a>00515     <span class="keywordflow">return</span> out + get_unique_res(latest_type()+<span class="stringliteral">&quot;*&quot;</span>) + <span class="stringliteral">&quot; = &quot;</span> + get_current_tmp();
<a name="l00516"></a>00516   }
<a name="l00517"></a>00517   
<a name="l00518"></a>00518   <span class="keywordtype">string</span> toplevel_asm(Form* in)
<a name="l00519"></a>00519   {
<a name="l00520"></a>00520     <span class="keywordflow">if</span>(cdr(in) == NULL)
<a name="l00521"></a>00521       error(<span class="stringliteral">&quot;No Assembly code provided.&quot;</span>,at(in));
<a name="l00522"></a>00522     <span class="keywordflow">return</span> (<span class="keywordtype">string</span>)<span class="stringliteral">&quot;module asm \&quot;&quot;</span> + cdr(in) + <span class="stringliteral">&quot;\&quot;\n&quot;</span>;
<a name="l00523"></a>00523   }
<a name="l00524"></a>00524   
<a name="l00525"></a>00525   <span class="keywordtype">string</span> inline_asm(Form* in)
<a name="l00526"></a>00526   {
<a name="l00527"></a>00527     <span class="keywordtype">string</span> out;
<a name="l00528"></a>00528     <span class="keywordtype">string</span> type = val(nth(in,1));
<a name="l00529"></a>00529     <span class="keywordtype">string</span> dialect = val(nth(in,2));
<a name="l00530"></a>00530     <span class="keywordtype">string</span> code = print(cdr(cdr(cdr(in))));
<a name="l00531"></a>00531     <span class="keywordflow">if</span>(dialect != <span class="stringliteral">&quot;Intel&quot;</span> &amp;&amp; dialect != <span class="stringliteral">&quot;ATT&quot;</span>)
<a name="l00532"></a>00532       error(<span class="stringliteral">&quot;Unknown assembly dialect: Only &#39;Intel&#39; and &#39;ATT&#39; are supported, &#39;&quot;</span>
<a name="l00533"></a>00533       ,dialect,<span class="stringliteral">&quot;&#39; was given.&quot;</span>,at(in));
<a name="l00534"></a>00534     out = allocate(get_unique_tmp(),type);
<a name="l00535"></a>00535     out += get_unique_tmp() + <span class="stringliteral">&quot; = call &quot;</span> + type + <span class="stringliteral">&quot; asm &quot;</span>
<a name="l00536"></a>00536         + ((dialect == <span class="stringliteral">&quot;Intel&quot;</span> ? <span class="stringliteral">&quot;inteldailect&quot;</span> : <span class="stringliteral">&quot;&quot;</span>)) + <span class="stringliteral">&quot; \&quot;&quot;</span> + code + <span class="stringliteral">&quot;\&quot;, &quot;</span><span class="stringliteral">&quot;()&quot;</span>;
<a name="l00537"></a>00537     <span class="keywordflow">return</span> out;
<a name="l00538"></a>00538   }
<a name="l00539"></a>00539   
<a name="l00540"></a>00540   <span class="keywordtype">void</span> init_stdlib()
<a name="l00541"></a>00541   {
<a name="l00542"></a>00542     Scope new_scope;
<a name="l00543"></a>00543     SymbolTable.push_back(new_scope);
<a name="l00544"></a>00544     <span class="comment">//Init Toplevel</span>
<a name="l00545"></a>00545     TopLevel[<span class="stringliteral">&quot;def&quot;</span>]              = &amp;def_global;
<a name="l00546"></a>00546     TopLevel[<span class="stringliteral">&quot;main&quot;</span>]             = &amp;main_fn;
<a name="l00547"></a>00547     TopLevel[<span class="stringliteral">&quot;LLVM&quot;</span>]             = &amp;embed_llvm;
<a name="l00548"></a>00548     TopLevel[<span class="stringliteral">&quot;function&quot;</span>]         = &amp;define_function;
<a name="l00549"></a>00549     TopLevel[<span class="stringliteral">&quot;recursive&quot;</span>]        = &amp;define_recursive;
<a name="l00550"></a>00550     TopLevel[<span class="stringliteral">&quot;fast&quot;</span>]             = &amp;define_fast;
<a name="l00551"></a>00551     TopLevel[<span class="stringliteral">&quot;inline&quot;</span>]           = &amp;define_inline;
<a name="l00552"></a>00552     TopLevel[<span class="stringliteral">&quot;inline-recursive&quot;</span>] = &amp;define_inline_recursive;
<a name="l00553"></a>00553     TopLevel[<span class="stringliteral">&quot;inline-fast&quot;</span>]      = &amp;define_inline_fast;
<a name="l00554"></a>00554     TopLevel[<span class="stringliteral">&quot;declare&quot;</span>]          = &amp;declare;
<a name="l00555"></a>00555     TopLevel[<span class="stringliteral">&quot;type&quot;</span>]             = &amp;makeType;
<a name="l00556"></a>00556     TopLevel[<span class="stringliteral">&quot;structure&quot;</span>]        = &amp;makeStructure;
<a name="l00557"></a>00557     TopLevel[<span class="stringliteral">&quot;generic&quot;</span>]          = &amp;genericInterface;
<a name="l00558"></a>00558     TopLevel[<span class="stringliteral">&quot;ASM&quot;</span>]              = &amp;toplevel_asm;
<a name="l00559"></a>00559     <span class="comment">//Init Core</span>
<a name="l00560"></a>00560     Core[<span class="stringliteral">&quot;def&quot;</span>]         = &amp;def_local;
<a name="l00561"></a>00561     Core[<span class="stringliteral">&quot;set&quot;</span>]         = &amp;<span class="keyword">set</span>;
<a name="l00562"></a>00562     Core[<span class="stringliteral">&quot;ret&quot;</span>]         = &amp;ret;
<a name="l00563"></a>00563     Core[<span class="stringliteral">&quot;add&quot;</span>]         = &amp;add;
<a name="l00564"></a>00564     Core[<span class="stringliteral">&quot;fadd&quot;</span>]        = &amp;fadd;
<a name="l00565"></a>00565     Core[<span class="stringliteral">&quot;sub&quot;</span>]         = &amp;fsub;
<a name="l00566"></a>00566     Core[<span class="stringliteral">&quot;fsub&quot;</span>]        = &amp;fsub;
<a name="l00567"></a>00567     Core[<span class="stringliteral">&quot;mul&quot;</span>]         = &amp;mul;
<a name="l00568"></a>00568     Core[<span class="stringliteral">&quot;fmul&quot;</span>]        = &amp;fmul;
<a name="l00569"></a>00569     Core[<span class="stringliteral">&quot;udiv&quot;</span>]        = &amp;udiv;
<a name="l00570"></a>00570     Core[<span class="stringliteral">&quot;sdiv&quot;</span>]        = &amp;sdiv;
<a name="l00571"></a>00571     Core[<span class="stringliteral">&quot;fdiv&quot;</span>]        = &amp;fdiv;
<a name="l00572"></a>00572     Core[<span class="stringliteral">&quot;urem&quot;</span>]        = &amp;urem;
<a name="l00573"></a>00573     Core[<span class="stringliteral">&quot;srem&quot;</span>]        = &amp;srem;
<a name="l00574"></a>00574     Core[<span class="stringliteral">&quot;frem&quot;</span>]        = &amp;frem;
<a name="l00575"></a>00575     Core[<span class="stringliteral">&quot;icmp&quot;</span>]        = &amp;icmp;
<a name="l00576"></a>00576     Core[<span class="stringliteral">&quot;fcmp&quot;</span>]        = &amp;fcmp;
<a name="l00577"></a>00577     Core[<span class="stringliteral">&quot;begin&quot;</span>]       = &amp;begin;
<a name="l00578"></a>00578     Core[<span class="stringliteral">&quot;if&quot;</span>]          = &amp;simple_if;
<a name="l00579"></a>00579     Core[<span class="stringliteral">&quot;flow&quot;</span>]        = &amp;flow;
<a name="l00580"></a>00580     Core[<span class="stringliteral">&quot;construct&quot;</span>]   = &amp;construct;
<a name="l00581"></a>00581     Core[<span class="stringliteral">&quot;access&quot;</span>]      = &amp;access;
<a name="l00582"></a>00582     Core[<span class="stringliteral">&quot;array&quot;</span>]       = &amp;local_array;
<a name="l00583"></a>00583     Core[<span class="stringliteral">&quot;nth&quot;</span>]         = &amp;nth_array;
<a name="l00584"></a>00584     Core[<span class="stringliteral">&quot;call&quot;</span>]        = &amp;direct_call;
<a name="l00585"></a>00585     Core[<span class="stringliteral">&quot;allocate&quot;</span>]    = &amp;mem_allocate;
<a name="l00586"></a>00586     Core[<span class="stringliteral">&quot;store&quot;</span>]       = &amp;mem_store;
<a name="l00587"></a>00587     Core[<span class="stringliteral">&quot;load&quot;</span>]        = &amp;mem_load;
<a name="l00588"></a>00588     Core[<span class="stringliteral">&quot;asm&quot;</span>]         = &amp;inline_asm;
<a name="l00589"></a>00589     <span class="comment">//Word macros</span>
<a name="l00590"></a>00590     addWordMacro(<span class="stringliteral">&quot;bool&quot;</span>,<span class="stringliteral">&quot;i1&quot;</span>);
<a name="l00591"></a>00591     addWordMacro(<span class="stringliteral">&quot;char&quot;</span>,<span class="stringliteral">&quot;i8&quot;</span>);
<a name="l00592"></a>00592     addWordMacro(<span class="stringliteral">&quot;short&quot;</span>,<span class="stringliteral">&quot;i16&quot;</span>);
<a name="l00593"></a>00593     addWordMacro(<span class="stringliteral">&quot;int&quot;</span>,<span class="stringliteral">&quot;i32&quot;</span>);
<a name="l00594"></a>00594     addWordMacro(<span class="stringliteral">&quot;long&quot;</span>,<span class="stringliteral">&quot;i64&quot;</span>);
<a name="l00595"></a>00595   }
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 19 2012 15:51:28 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
